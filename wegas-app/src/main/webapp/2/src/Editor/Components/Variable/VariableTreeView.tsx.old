import * as React from 'react';
import { VariableDescriptor } from '../../../data/selectors';
import { Actions } from '../../../data';
import { Toolbar } from '../../../Components/Toolbar';
import { varIsList, entityIs } from '../../../data/entities';
import { get } from 'lodash-es';
import { Container, Node } from '../Views/TreeView';
import { moveDescriptor } from '../../../data/Reducer/VariableDescriptorReducer';
import {
  getEntityActions,
  getIcon,
  getClassLabel,
  getChildren,
} from '../../editionConfig';
import { StoreDispatch, useStore, store } from '../../../data/Stores/store';
import { css, cx } from 'emotion';
import { shallowIs } from '../../../Helper/shallowIs';
import { DropMenu } from '../../../Components/DropMenu';
import { withDefault, IconComp } from '../Views/FontAwesome';
import { asyncSFC } from '../../../Components/HOC/asyncSFC';
import { AddMenuParent, AddMenuChoice, AddMenuFeedback } from './AddMenu';
import { editorLabel } from '../../../data/methods/VariableDescriptorMethods';
import { useAsync } from '../../../Components/Hooks/useAsync';
import { ComponentWithForm } from '../FormView/ComponentWithForm';
import { useGameModel } from '../../../Components/Hooks/useGameModel';
import { Edition } from '../../../data/Reducer/globalState';
import { mainLayoutId } from '../Layout';
import { themeVar } from '../../../Components/Theme/ThemeVars';
import {
  globalSelection,
  localSelection,
  componentMarginLeft,
  flex,
  grow,
  flexColumn,
  toolboxHeaderStyle,
  flexRow,
  flexBetween,
} from '../../../css/classes';
import {
  IVariableDescriptor,
  IEvaluationDescriptorContainer,
  IResult,
} from 'wegas-ts-api';
import { focusTab } from '../LinearTabLayout/LinearLayout';
import { State } from '../../../data/Reducer/reducers';
import { isActionAllowed } from '../../../Components/PageComponents/tools/options';
import { SimpleInput } from '../../../Components/Inputs/SimpleInput';
import { useOkCancelModal } from '../../../Components/Modal';
import { useInternalTranslate } from '../../../i18n/internalTranslator';
import { commonTranslations } from '../../../i18n/common/common';
import { Toggler } from '../../../Components/Inputs/Boolean/Toggler';
import { useDebounceFn } from '../../../Components/Hooks/useDebounce';

const TREECONTENTID = 'TREECONTENT';
const nodeStyle = css({
  borderStyle: 'solid',
  borderWidth: '1px',
  borderColor: 'transparent',
  borderRadius: themeVar.dimensions.BorderRadius,
  padding: '2px',
  alignItems: 'center',
});

export const nodeContentStyle = cx(
  css({
    marginRight: '5px',
  }),
  componentMarginLeft,
);

export const actionNodeContentStyle = cx(
  css({
    cursor: 'pointer',
    ':hover': {
      border: '1px solid ' + themeVar.colors.PrimaryColor,
    },
  }),
);

const itemsPromise = getChildren({ '@class': 'ListDescriptor' }).then(
  children =>
    children.map(i => {
      const Label = asyncSFC(async () => {
        const entity = { '@class': i };
        return (
          <>
            <IconComp
              icon={withDefault(getIcon(entity), 'question')}
              className={css({ marginRight: '3px' })}
            />
            {getClassLabel(entity)}
          </>
        );
      });
      return {
        label: <Label />,
        value: i,
      };
    }),
);

interface VariableTreeTitleProps extends ClassStyleId {
  variable?: IVariableDescriptor | IResult | IEvaluationDescriptorContainer;
  subPath?: (string | number)[];
}

export function VariableTreeTitle({
  variable,
  subPath,
  className,
  style,
}: VariableTreeTitleProps) {
  return (
    <div className={className} style={style}>
      <IconComp
        icon={withDefault(getIcon(variable!), 'question')}
        className={css({ marginRight: '2px' })}
      />
      {entityIs(variable, 'EvaluationDescriptorContainer')
        ? subPath && subPath.length === 1
          ? String(subPath[0]) === 'feedback'
            ? 'Feedback'
            : 'Feedback comment'
          : 'Unreachable code'
        : editorLabel(variable)}
    </div>
  );
}

interface TreeProps extends DisabledReadonly {
  variables: number[];
  noHeader?: boolean;
  noVisibleRoot?: boolean;
  localState?: Readonly<Edition> | undefined;
  localDispatch?: StoreDispatch;
  forceLocalDispatch?: boolean;
}
export function VariableTreeView({
  variables,
  noHeader = false,
  noVisibleRoot = false,
  localState,
  localDispatch,
  forceLocalDispatch,
  ...options
}: TreeProps) {
  // const [search, setSearch] = React.useState('');
  const [onAccept, setOnAccept] = React.useState(() => () => {});

  const { data } = useAsync(itemsPromise);
  const { showModal, OkCancelModal } = useOkCancelModal(TREECONTENTID);
  const i18nValues = useInternalTranslate(commonTranslations);

  const globalDispatch = store.dispatch;
  const actionAllowed = isActionAllowed(options);
  const { value, deep } = useStore(s => s.global.search);

  const searchFn = useDebounceFn(
    (value: string) =>
      globalDispatch(
        value.length < 2
          ? Actions.EditorActions.clearSearch()
          : Actions.EditorActions.search(value),
      ),
    500,
  );

  return (
    <Toolbar className={css({ padding: '1.5em' })}>
      <Toolbar.Header className={cx(toolboxHeaderStyle, flexBetween)}>
        {!noHeader && actionAllowed && (
          <>
            <DropMenu
              tooltip={i18nValues.add}
              items={data || []}
              icon="plus"
              onSelect={(i, e) => {
                if ((e.ctrlKey || forceLocalDispatch) && localDispatch) {
                  localDispatch(Actions.EditorActions.createVariable(i.value));
                } else {
                  globalDispatch(Actions.EditorActions.createVariable(i.value));
                  focusTab(mainLayoutId, 'Variable Properties');
                }
              }}
            />
            <div className={cx(flex, flexRow)}>
              <SimpleInput
                value={value}
                placeholder={i18nValues.filter}
                aria-label="Filter"
                onChange={ev => searchFn(String(ev))}
              />
              <Toggler
                className={css({
                  fontSize: '14px',
                  lineHeight: '100%',
                  justifyContent: 'flex-end',
                  marginLeft: '5px',
                })}
                label={i18nValues.deepSearch}
                value={deep}
                onChange={value =>
                  globalDispatch(Actions.EditorActions.searchSetDeep(value))
                }
              />
            </div>
          </>
        )}
      </Toolbar.Header>
      <Toolbar.Content id={TREECONTENTID} className={css({ padding: '1px' })}>
        <OkCancelModal onOk={onAccept}>
          <p>{i18nValues.changesWillBeLost}</p>
          <p>{i18nValues.areYouSure}</p>
        </OkCancelModal>
        <Container
          onDropResult={({ source, target, id }) => {
            if (
              source.parent !== target.parent ||
              source.index !== target.index
            ) {
              let dispatch = store.dispatch;
              if (forceLocalDispatch && localDispatch) {
                dispatch = localDispatch;
              }
              dispatch(
                moveDescriptor(
                  id as IVariableDescriptor,
                  target.index,
                  target.parent as IParentDescriptor,
                ),
              );
            }
          }}
        >
          {({ nodeProps }) => (
            <div className={cx(flex, grow, flexColumn)}>
              {variables ? (
                variables.map(id => (
                  <CTree
                    onShowWarning={onOk => {
                      setOnAccept(() => onOk);
                      showModal();
                    }}
                    nodeProps={nodeProps}
                    key={id}
                    variableId={id}
                    noVisibleRoot={noVisibleRoot}
                    localState={localState}
                    localDispatch={localDispatch}
                    forceLocalDispatch={forceLocalDispatch}
                    {...options}
                  />
                ))
              ) : (
                <span>{`${i18nValues.loading} ...`}</span>
              )}
            </div>
          )}
        </Container>
      </Toolbar.Content>
    </Toolbar>
  );
}

/**
 * test a variable and children's editorLabel against a text
 */
function isMatch(variableId: number, search: string, deep: boolean): boolean {
  const variable = VariableDescriptor.select(variableId);
  if (variable == null) {
    return false;
  }
  if (
    deep &&
    Object.values(variable).filter(value =>
      JSON.stringify(value).toLowerCase().includes(search.toLowerCase()),
    ).length > 0
  ) {
    return true;
  }
  if (editorLabel(variable).toLowerCase().includes(search.toLowerCase())) {
    return true;
  }
  if (varIsList(variable)) {
    return variable.itemsIds.some(id => isMatch(id, search, deep));
  }
  return false;
}

function isEditing(
  variableId: number,
  subPath?: string[],
  editing?: Readonly<Edition>,
) {
  return (
    editing !== undefined &&
    (editing.type === 'Variable' || editing.type === 'VariableFSM') &&
    editing.entity &&
    variableId === editing.entity.id &&
    shallowIs(subPath || [], editing.path)
  );
}

export const TREEVIEW_ITEM_TYPE = 'TREEVIEW_DRAG_ITEM';

interface CTreeProps {
  variableId: number;
  subPath?: string[];
  nodeProps: () => {};
  onShowWarning?: (onAccept: () => void) => void;
}

export function CTree({
  nodeProps,
  variableId,
  disabled,
  forceLocalDispatch,
  localDispatch,
  localState,
  noVisibleRoot,
  onShowWarning,
  readOnly,
  subPath,
}: Omit<CTreeProps & TreeProps, 'variables' | 'noHeader'>): JSX.Element | null {
  const i18nValues = useInternalTranslate(commonTranslations);
  const actionAllowed = isActionAllowed({
    disabled: disabled,
    readOnly: readOnly,
  });

  const infoSelector = React.useCallback(
    (state: State) => {
      let variable:
        | undefined
        | IVariableDescriptor
        | IResult
        | IEvaluationDescriptorContainer =
        VariableDescriptor.select(variableId);
      if (Array.isArray(subPath) && subPath.length > 0) {
        variable = get(variable, subPath) as
          | IVariableDescriptor
          | IResult
          | IEvaluationDescriptorContainer;
      }

      return {
        variable: variable,
        match: isMatch(
          variableId,
          state.global.search.value || '',
          state.global.search.deep,
        ),
        editing: isEditing(variableId, subPath, state.global.editing),
        searching: state.global.search.value != null,
      };
    },
    [subPath, variableId],
  );

  const { editing, variable, match, searching } = useStore(infoSelector);

  const localEditing = isEditing(variableId, subPath, localState);

  const onClickAction = React.useCallback(
    (e: ModifierKeysEvent) => {
      let dispatch = store.dispatch;
      if ((forceLocalDispatch || e.ctrlKey) && localDispatch) {
        dispatch = localDispatch;
      } else {
        if (
          entityIs(variable, 'FSMDescriptor') ||
          entityIs(variable, 'DialogueDescriptor')
        ) {
          focusTab(mainLayoutId, 'State Machine');
        }
        focusTab(mainLayoutId, 'Variable Properties');
      }
      getEntityActions(variable!).then(({ edit }) =>
        dispatch(edit(VariableDescriptor.select(variableId)!, subPath)),
      );
    },
    [forceLocalDispatch, localDispatch, subPath, variableId, variable],
  );

  if (variable) {
    if (!match) {
      return null;
    }
    return (
      <Node
        noToggle={noVisibleRoot}
        disabled={disabled}
        dragId={TREEVIEW_ITEM_TYPE}
        dragDisabled={!actionAllowed}
        dropDisabled={!actionAllowed}
        expanded={searching && match}
        {...nodeProps()}
        header={
          <div
            className={cx(flex, nodeStyle, {
              [globalSelection]: editing,
              [localSelection]: localEditing,
              [actionNodeContentStyle]: actionAllowed,
            })}
            onClick={(e: ModifierKeysEvent) => {
              if (actionAllowed) {
                const unsaved =
                  forceLocalDispatch || e.ctrlKey
                    ? localState?.unsaved
                    : store.getState().global.editing?.unsaved;
                if (unsaved && onShowWarning) {
                  onShowWarning(() => onClickAction(e));
                } else {
                  onClickAction(e);
                }
              }
            }}
          >
            {!noVisibleRoot && (
              <VariableTreeTitle
                variable={variable}
                subPath={subPath}
                className={nodeContentStyle}
              />
            )}
            {actionAllowed &&
              (entityIs(variable, 'ListDescriptor') ||
              entityIs(variable, 'QuestionDescriptor') ||
              entityIs(variable, 'WhQuestionDescriptor') ? (
                <AddMenuParent
                  label={noVisibleRoot ? 'Add' : undefined}
                  prefixedLabel={!noVisibleRoot}
                  variable={variable}
                  localDispatch={localDispatch}
                  focusTab={tabId => focusTab(mainLayoutId, tabId)}
                  forceLocalDispatch={forceLocalDispatch}
                  style={noVisibleRoot ? { marginBottom: '10px' } : undefined}
                />
              ) : entityIs(variable, 'ChoiceDescriptor') ? (
                <AddMenuChoice
                  variable={variable}
                  localDispatch={localDispatch}
                  focusTab={tabId => focusTab(mainLayoutId, tabId)}
                  forceLocalDispatch={forceLocalDispatch}
                />
              ) : entityIs(variable, 'EvaluationDescriptorContainer') ? (
                <AddMenuFeedback
                  variable={variable}
                  localDispatch={localDispatch}
                  focusTab={tabId => focusTab(mainLayoutId, tabId)}
                  path={subPath![0] as 'feedback' | 'fbComments'}
                  forceLocalDispatch={forceLocalDispatch}
                />
              ) : null)}
          </div>
        }
        id={variable}
      >
        {({ nodeProps }) =>
          varIsList(variable)
            ? variable.itemsIds.map(i => (
                <CTree
                  nodeProps={nodeProps}
                  key={i}
                  variableId={i}
                  localState={localState}
                  localDispatch={localDispatch}
                  forceLocalDispatch={forceLocalDispatch}
                  disabled={disabled}
                  readOnly={readOnly}
                  onShowWarning={onShowWarning}
                />
              ))
            : entityIs(variable, 'ChoiceDescriptor')
            ? variable.results.map((r, index) => (
                <CTree
                  nodeProps={nodeProps}
                  key={r.id}
                  variableId={r.parentId!}
                  subPath={['results', String(index)]}
                  localState={localState}
                  localDispatch={localDispatch}
                  forceLocalDispatch={forceLocalDispatch}
                  disabled={disabled}
                  readOnly={readOnly}
                  onShowWarning={onShowWarning}
                />
              ))
            : entityIs(variable, 'PeerReviewDescriptor')
            ? [
                <CTree
                  nodeProps={nodeProps}
                  key={0}
                  variableId={variableId}
                  subPath={['feedback']}
                  localState={localState}
                  localDispatch={localDispatch}
                  forceLocalDispatch={forceLocalDispatch}
                  disabled={disabled}
                  readOnly={readOnly}
                  onShowWarning={onShowWarning}
                />,
                <CTree
                  nodeProps={nodeProps}
                  key={1}
                  variableId={variableId}
                  subPath={['fbComments']}
                  localState={localState}
                  localDispatch={localDispatch}
                  forceLocalDispatch={forceLocalDispatch}
                  disabled={disabled}
                  readOnly={readOnly}
                  onShowWarning={onShowWarning}
                />,
              ]
            : entityIs(variable, 'EvaluationDescriptorContainer')
            ? variable.evaluations.map((r, index) => (
                <CTree
                  nodeProps={nodeProps}
                  key={r.id}
                  variableId={variableId}
                  subPath={[
                    ...(subPath ? subPath : []),
                    'evaluations',
                    String(index),
                  ]}
                  localState={localState}
                  localDispatch={localDispatch}
                  forceLocalDispatch={forceLocalDispatch}
                  disabled={disabled}
                  readOnly={readOnly}
                  onShowWarning={onShowWarning}
                />
              ))
            : null
        }
      </Node>
    );
  }
  return <div>{i18nValues.loading}...</div>;
}
export function Tree() {
  const entities = useGameModel().itemsIds;
  return <VariableTreeView variables={entities} />;
}

export default function TreeWithMeta() {
  const entities = useGameModel().itemsIds;
  return (
    <ComponentWithForm entityEditor>
      {({ localState, localDispatch }) => {
        return (
          <VariableTreeView
            variables={entities}
            localState={localState}
            localDispatch={localDispatch}
          />
        );
      }}
    </ComponentWithForm>
  );
}
