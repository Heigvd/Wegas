/*
 * Wegas
 * http://www.albasim.com/wegas/
 *
 * School of Business and Engineering Vaud, http://www.heig-vd.ch/
 * Media Engineering :: Information Technology Managment :: Comem
 *
 * Copyright (C) 2012
 */

/**
 * @author Francois-Xavier Aeberhard <fx@red-agent.com>
 */

YUI.add('wegas-widgetmenu', function (Y) {
    "use strict";

    /**
     *  @class WidgetMenu
     *  @module Wegas
     *  @constructor
     */
    var  WidgetMenu = function () {
        WidgetMenu.superclass.constructor.apply(this, arguments);
    };

    WidgetMenu.NS = "menu";
    WidgetMenu.NAME = "widgetmenu";

    Y.extend(WidgetMenu, Y.Plugin.Base, {

        // *** Lifecycle methods *** //
        initializer: function () {
            this.afterHostEvent( "render", function () {
                this.get( "host" ).get( "contentBox" ).delegate( this.get( "event" ), function ( e ) {
                    var menu = this.getMenu();                                  // Get a menu instance

                    menu.attachTo( e.target );                                  // Attach it to the target node
                    menu.addTarget( this );                                     // Catch any event generated by the menu
                    e.halt();                                                   // Prevent event from bubbling
                    this.fire( "menuOpen" );                                    // Notify the parent the menu has been opened

                }, this.get( "selector" ), this );
            });
        },

        // *** Private methods *** //

        getMenu: function () {
            if ( !this.menu ) {
                var cfg = this.get( "menuCfg" );
                cfg.children = this.get( "children" );

                this.menu = new Y.Wegas.Menu( cfg );

                var parentWidget = this.get( "host" ).get( "parent" );          // Handle nested menus, events are forwarded to the parent widget
                if ( parentWidget && parentWidget instanceof Y.Wegas.Menu ) {
                    this.menu.on( "timerCanceled", function () {
                        parentWidget.cancelMenuTimer();
                    }, this);

                    this.menu.on( "timerStarted", function () {
                        parentWidget.startMenuHideTimer();
                    }, this);
                };
            }
            return this.menu;
        }
    }, {
        ATTRS: {
            children: {
                value: []
            },
            selector: {
                value: "*"
            },
            menuCfg: {
                value: {}
            },
            event: {
                value: "click"
            }
        }
    //menu: null
    });

    Y.namespace( 'Plugin' ).WidgetMenu = WidgetMenu;

    Y.namespace( 'Wegas' ).Menu = Y.Base.create( "menu" , Y.Widget,
        [ Y.WidgetPosition,  Y.WidgetPositionAlign, Y.WidgetStack, Y.WidgetParent, Y.WidgetPositionConstrain ], {

            // *** private fields *** //

            timer: null,

            // *** Lifecycle methods *** //
            initializer: function () {
                this.publish( "click", {
                    emitFacade: true,
                    bubbles: true
                });
                this.publish( "cancelMenuTimer", {
                    bubbles: true
                })
            },

            renderUI: function () {
                var bb = this.get( "boundingBox" );

                bb.on("clickoutside", this.hide, this );
                bb.on( "click", this.menuClick, this );
                bb.on( "mouseenter", this.cancelMenuTimer, this );
                bb.on( "mouseleave", this.startMenuHideTimer, this );
            },

            bindUI: function () {
                this.on( "*:click", function ( e ) {                            // @hack in order for event to be bubbled up
                    //Y.log("fix");
                    }, this);
            },

            // *** Public methods *** //
            /**
            *
            *  Displays the menu next to the provided node and add mouseenter and
            *  mouseleave callbacks to the node
            *
            * @method attachTo
            */

            attachTo: function ( node ) {

                //node.on( "mouseenter", this.show, this);
                //node.on( "mouseleave", this.hide, this);

                this.set( "align", {
                    node: node,
                    points: this.get( "points" )
                });

                this.cancelMenuTimer();
                this.show();
            },

            // *** Private methods *** //
            menuClick: function () {
                this.hide();
                this.fire( "menuClick" );
            },

            startMenuHideTimer: function () {
                this.cancelMenuTimer();
                this.timer = Y.later( 500, this, this.hide );

                this.fire( "timerStarted" );
            },
            cancelMenuTimer: function () {
                if ( this.timer ) {
                    this.timer.cancel();
                }
                this.fire( "timerCanceled" );
            }
        }, {
            ATTRS: {
                points: {
                    value: [ "tl", "bl" ]
                },
                constrain: {
                    value: true
                },
                zIndex:{
                    value: 25
                },
                width: {
                    value: "12em"
                },
                render: {
                    value: true
                },
                visible: {
                    value: false
                },
                defaultChildType: {
                    value: "Button"
                }
            }
        });
});


